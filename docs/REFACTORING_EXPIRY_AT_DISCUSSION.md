# Обсуждение рефакторинга expiry_at в ключах

## Текущая ситуация

### Статистика
- **Все ключи привязаны к подпискам**: 
  - Outline: 31 ключей, все с `subscription_id`
  - V2Ray: 62 ключей, все с `subscription_id`
  - Standalone ключи (без subscription_id): 0

### Проблема
- Дублирование данных: `expiry_at` хранится и в `keys`/`v2ray_keys`, и в `subscriptions`
- Риск рассинхронизации (как мы видели - Outline ключи не обновлялись)
- ~122 места в коде используют `expiry_at` из таблиц ключей

### Использование в коде
1. **Фильтрация активных ключей**: `WHERE expiry_at > ?` - очень часто
2. **Отображение срока действия** в UI
3. **Проверка наличия активных ключей** для платежей
4. **Миграционные скрипты** работают со standalone ключами (но их уже нет)

---

## Варианты рефакторинга

### Вариант 1: Полное удаление expiry_at из ключей

**Идея**: Удалить поле `expiry_at` из таблиц `keys` и `v2ray_keys`, всегда брать из `subscriptions`.

**Плюсы**:
- ✅ Единственный источник правды
- ✅ Невозможна рассинхронизация
- ✅ Соответствует нормализации БД
- ✅ Меньше места в БД

**Минусы**:
- ❌ Все запросы требуют JOIN с subscriptions (122 места)
- ❌ Производительность: JOIN медленнее, чем прямой доступ к полю
- ❌ Нужно обрабатывать случаи с NULL subscription_id (хотя их сейчас нет)
- ❌ Огромный объем изменений в коде

**Изменения в SQL**:
```sql
-- Было:
SELECT * FROM keys WHERE expiry_at > ?

-- Станет:
SELECT k.*, s.expires_at 
FROM keys k
JOIN subscriptions s ON k.subscription_id = s.id
WHERE s.expires_at > ?
```

---

### Вариант 2: Использование VIEW с вычисляемым полем

**Идея**: Создать VIEW, который вычисляет `expiry_at` из подписки, но оставить поле в таблицах.

**Плюсы**:
- ✅ Постепенная миграция возможна
- ✅ Старый код продолжает работать
- ✅ Новый код может использовать VIEW

**Минусы**:
- ❌ Все еще есть дублирование в реальных таблицах
- ❌ Не решает проблему рассинхронизации полностью
- ❌ Два источника данных (таблица vs VIEW)

---

### Вариант 3: Триггеры для синхронизации

**Идея**: Оставить `expiry_at` в ключах, но создать триггеры, которые автоматически обновляют его при изменении `subscriptions.expires_at`.

**Плюсы**:
- ✅ Минимальные изменения в коде
- ✅ Автоматическая синхронизация
- ✅ Производительность сохраняется

**Минусы**:
- ❌ Все еще дублирование данных
- ❌ Сложность отладки (неявное поведение)
- ❌ Возможны edge cases при удалении/создании подписок
- ❌ SQLite ограничения на триггеры

**Пример триггера**:
```sql
CREATE TRIGGER sync_key_expiry_on_subscription_update
AFTER UPDATE OF expires_at ON subscriptions
BEGIN
    UPDATE keys SET expiry_at = NEW.expires_at 
    WHERE subscription_id = NEW.id;
    UPDATE v2ray_keys SET expiry_at = NEW.expires_at 
    WHERE subscription_id = NEW.id;
END;
```

---

### Вариант 4: Компромисс - только для ключей с subscription_id

**Идея**: Убрать `expiry_at` только для ключей с `subscription_id`, оставить для standalone (хотя их сейчас нет).

**Плюсы**:
- ✅ Решает основную проблему (ключи подписок)
- ✅ Гибкость для будущих standalone ключей
- ✅ Можно делать постепенно

**Минусы**:
- ❌ Все еще есть дублирование для подписок
- ❌ Усложняет логику (проверка subscription_id)

---

## Рекомендация: Вариант 3 (Триггеры) + постепенная миграция

### Фаза 1: Добавить триггеры (быстро, безопасно)
- Создать триггеры для автоматической синхронизации
- Исправить текущий баг (уже сделано)
- Тесты и мониторинг

### Фаза 2: Постепенная миграция кода (опционально)
- Создать VIEW для новых запросов
- Постепенно мигрировать код на использование `subscriptions.expires_at`
- В конечном итоге можно удалить поле (если производительность позволяет)

---

## Вопросы для обсуждения

1. **Производительность**: Насколько критична производительность? JOIN с subscriptions будет медленнее, но насколько?

2. **Standalone ключи**: Нужны ли они в будущем? Если нет - можно упростить логику.

3. **Объем изменений**: Готовы ли мы менять 122 места в коде? Или предпочтительнее триггеры?

4. **Тестирование**: Как обеспечить тестирование всех сценариев после рефакторинга?

5. **Откат**: Нужен ли план отката на случай проблем?

---

## Альтернатива: Оставить как есть с улучшенной синхронизацией

Если объем изменений слишком большой, можно:
- Добавить проверки в CI/CD, что `expiry_at` синхронизирован
- Улучшить метод `update_subscription_keys_expiry` (уже сделано)
- Добавить валидацию при изменении подписки
- Периодические скрипты синхронизации для проверки

---

## Метрики для оценки

После выбора подхода нужно измерить:
- Время выполнения типичных запросов до/после
- Количество запросов с JOIN vs без
- Размер БД (экономия места при удалении поля)
- Время миграции кода

